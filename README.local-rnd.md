# Local R&D Plan - DXC Wasm + LLVM IR -> Wasm Fast Dispatch

Local planning/execution doc only.
Do not commit.
Do not push.

## Objective

Deliver locally, end-to-end:

1. DXC running inside Wasm for runtime `HLSL -> SPIR-V`
2. Fast shader execute path in llvmpipe via `LLVM IR -> Wasm`
3. Runtime smoke that compiles HLSL in Wasm, creates Vulkan compute pipeline, dispatches, and proves fast Wasm path usage

## Constraints

- Local-only iteration
- Commits allowed locally if needed
- No push to any remote in this phase
- Smoke proof must be machine-readable

## Runtime design

### Shader source path

- JS smoke harness compiles HLSL at runtime using Wasm DXC (`dxc.js`) to SPIR-V bytes
- SPIR-V bytes are injected into the C smoke via `webvulkan_set_runtime_shader_spirv`
- Vulkan path creates `VkShaderModule` and compute pipeline from injected SPIR-V

### Fast execute path

- At dispatch, llvmpipe Emscripten path uses `lp_webvulkan_run_store_wasm_js`
- That path runs injected `LLVM IR -> Wasm` module generated by `clang/clang` in Wasm
- If module requires shared-memory import, runtime uses a dedicated shared-memory shim and writes result back to target SSBO bytes
- Smoke enforces proof markers:
  - `proof.codegen=llvm_ir_to_wasm`
  - `proof.execute_path=fast_wasm`
  - `proof.interpreter=disabled_for_dispatch`

## Work packages

### A. DXC Wasm

- Fork remote: `https://github.com/Devsh-Graphics-Programming/DirectXShaderCompiler`
- Branch: `wasm`
- Local Wasm DXC artifact consumed from `tmp/dxc-wasm-build/bin/dxc.js`
- Runtime smoke uses this artifact to compile inline HLSL to SPIR-V

### B. Mesa fast path hardening (Emscripten)

- Device creation stability patches for Emscripten path in lavapipe
- Defensive handle callback usage (`create_texture_handle`/`create_image_handle` nullable)
- Emscripten-safe compute/flush cleanup adjustments to avoid draw teardown traps in smoke scope
- Build-state signature fix in CMake Mesa subbuild so option changes trigger proper reconfigure

### C. Smoke proof

- Vulkan loader path: Volk with custom `vk_icdGetInstanceProcAddr`
- Runtime compile proof:
  - HLSL compiled in Wasm by DXC
  - LLVM IR compiled in Wasm by clang package
- Dispatch proof:
  - expected value `0x12345678`
  - observed value `0x12345678`
- Driver identity proof:
  - `device.name` contains `llvmpipe`
  - `driver.name` contains `llvmpipe`

## Current local status

- [x] Runtime DXC Wasm compile path active
- [x] Runtime LLVM IR -> Wasm injection active
- [x] Vulkan compute dispatch succeeds with expected output
- [x] Fast-path proof lines printed and validated
- [x] `cmake --build build --target lavapipe_runtime_smoke --config Release` passes

## Last validated command

`cmake --build build --target lavapipe_runtime_smoke --config Release`

Key proof lines from passing run:

- `shader.source=runtime_injected_spirv`
- `shader.dispatch=ok`
- `shader.dispatch.expected=0x12345678`
- `shader.dispatch.observed=0x12345678`
- `proof.codegen=llvm_ir_to_wasm`
- `proof.execute_path=fast_wasm`
- `proof.interpreter=disabled_for_dispatch`
- `runtime smoke passed`

## Next local tasks before any push

1. Remove temporary verbose debug logging from Mesa smoke hardening patches
2. Decide which Emscripten safety patches stay productized vs smoke-only
3. Re-run full tests target set after cleanup
4. Prepare minimal commit split (toolchain/smoke/mesa patches) for review
